exit
vend
c
n
c
n
@current_selection[:price]
@current_amount
c
n
@current_amount > @current_selection[:price]
c
n
self
c
n
@current_amount > @current_selection[:price]
self
n
vend
n
c
n
user_input
self
vend
c
n
exit
@current_amount
vend
vend.make_change
n
c
n
self
@current_amount > @current_selection[:price]
n
@current_amount
@current_selection
n
self.current_selection
@current_selection
@current_seletion
current_selection
c
exit
@current_selection
@current_amount > @current_selection[:price]
vend
n
vend
n
vend
n
c
exit
@current_selection[:price]
@current_amount
c
n
c
n
c
n
self
n
self
n
self
n
self
c
n
c
n
c
vend=VendingMachine.new
vend
c
user_input.to_i
user_input
@current_selection
n
u_input
s
c
n
c
@current_selection[:price]==@current_amount
self
c
self
@current_selection[:price]==@current_amount
@current_selection
n
@current_selection
v
c
user_input.chomp
user_input
c
n
@current_selection[:price]
@current_selection
n
c
n
c
n
vend
c
n
c
@current_selection[:price]==@current_amount
@current_selection
n
user_input
c
n
c
self
c
vend.current_selection
item
c
vend.button_press(2)
c
exit
exti
vend.products.length
vend.products.first[:price]
vend.products.first[price]
vend.products.first.price
vend.products.first
vend.products
vend.proudcts
c
exit
products.first[1].to_f
products.first[0]
products.first
puts menu
exit
puts menu
menu
c
exit
products.to_a
products.first
products
exit
@products.each_with_index{|item, ind| puts "#{ind}. #{item}\n"}
@products(1)
@products
exit
vend.display_products
vend
exit
COINS
exit
COINS
exit
COINS[:nickel]
COINS['nickel']
COINS
c
c["nickel"]
c[n.to_sym]
c[n]
n="nickel"
c=c[:nickel]
c.nickel
c=COINS
c
:nickel
COINS.nickel
COINS
exit
puts "#{COINS.nickel}"
COINS
c
COINS
expect(vend.instance_of?(VendingMachine)).to eq(false)
expect(vend.instance_of?(VendingMachine)).to eq(true)
expect(vend.instance_of?(VendingMachine).to eq(true)
expect(vend).to eq(VendingMachine)
described_class
expect(described_class).to eq(VendingMachine)
exit
output=$stdout
VendingMachine.new
$stdout
